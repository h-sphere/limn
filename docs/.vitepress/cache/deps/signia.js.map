{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/ArraySet.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/helpers.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/capture.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/types.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/HistoryBuffer.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/constants.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/transactions.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/Atom.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/Computed.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/EffectScheduler.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/isSignal.ts", "../../../../node_modules/.pnpm/signia@0.1.5/node_modules/signia/src/index.ts"],
  "sourcesContent": ["// The maximum size for an array in an ArraySet\nexport const ARRAY_SIZE_THRESHOLD = 8\n\n/**\n * An ArraySet operates as an array until it reaches a certain size, after which a Set is used\n * instead. In either case, the same methods are used to get, set, remove, and visit the items.\n * @internal\n */\nexport class ArraySet<T> {\n\tprivate arraySize = 0\n\n\tprivate array: (T | undefined)[] | null = Array(ARRAY_SIZE_THRESHOLD)\n\n\tprivate set: Set<T> | null = null\n\n\t/**\n\t * Get whether this ArraySet has any elements.\n\t *\n\t * @returns True if this ArraySet has any elements, false otherwise.\n\t */\n\tget isEmpty() {\n\t\tif (this.array) {\n\t\t\treturn this.arraySize === 0\n\t\t}\n\n\t\tif (this.set) {\n\t\t\treturn this.set.size === 0\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Add an item to the ArraySet if it is not already present.\n\t *\n\t * @param elem - The element to add.\n\t */\n\n\tadd(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// Return false if the element is already in the array.\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif (this.arraySize < ARRAY_SIZE_THRESHOLD) {\n\t\t\t\t// If the array is below the size threshold, push items into the array.\n\n\t\t\t\t// Insert the element into the array's next available slot.\n\t\t\t\tthis.array[this.arraySize] = elem\n\t\t\t\tthis.arraySize++\n\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\t// If the array is full, convert it to a set and remove the array.\n\t\t\t\tthis.set = new Set(this.array as any)\n\t\t\t\tthis.array = null\n\t\t\t\tthis.set.add(elem)\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// Return false if the element is already in the set.\n\t\t\tif (this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.add(elem)\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Remove an item from the ArraySet if it is present.\n\t *\n\t * @param elem - The element to remove\n\t */\n\tremove(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// If the item is not in the array, return false.\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.array[idx] = undefined\n\t\t\tthis.arraySize--\n\n\t\t\tif (idx !== this.arraySize) {\n\t\t\t\t// If the item is not the last item in the array, move the last item into the\n\t\t\t\t// removed item's slot.\n\t\t\t\tthis.array[idx] = this.array[this.arraySize]\n\t\t\t\tthis.array[this.arraySize] = undefined\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// If the item is not in the set, return false.\n\t\t\tif (!this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.delete(elem)\n\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Run a callback for each element in the ArraySet.\n\t *\n\t * @param visitor The callback to run for each element.\n\t */\n\tvisit(visitor: (item: T) => void) {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tvisitor(elem)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (this.set) {\n\t\t\tthis.set.forEach(visitor)\n\n\t\t\treturn\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n}\n", "import { Child, Signal } from './types.js'\n\n/**\n * Get whether the given value is a child.\n *\n * @param x The value to check.\n * @returns True if the value is a child, false otherwise.\n */\nfunction isChild(x: any): x is Child {\n\treturn x && typeof x === 'object' && 'parents' in x\n}\n\n/**\n * Get whether a child's parents have changed.\n *\n * @param child The child to check.\n * @returns True if the child's parents have changed, false otherwise.\n */\nexport function haveParentsChanged(child: Child) {\n\tfor (let i = 0, n = child.parents.length; i < n; i++) {\n\t\t// Get the parent's value without capturing it.\n\t\tchild.parents[i].__unsafe__getWithoutCapture()\n\n\t\t// If the parent's epoch does not match the child's view of the parent's epoch, then the parent has changed.\n\t\tif (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Detach a child from a parent.\n *\n * @param parent The parent to detach from.\n * @param child The child to detach.\n */\nexport const detach = (parent: Signal<any>, child: Child) => {\n\t// If the child is not attached to the parent, do nothing.\n\tif (!parent.children.remove(child)) {\n\t\treturn\n\t}\n\n\t// If the parent has no more children, then detach the parent from its parents.\n\tif (parent.children.isEmpty && isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tdetach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Attach a child to a parent.\n *\n * @param parent The parent to attach to.\n * @param child The child to attach.\n */\nexport const attach = (parent: Signal<any>, child: Child) => {\n\t// If the child is already attached to the parent, do nothing.\n\tif (!parent.children.add(child)) {\n\t\treturn\n\t}\n\n\t// If the parent itself is a child, add the parent to the parent's parents.\n\tif (isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tattach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Get whether two values are equal (insofar as signia is concerned).\n *\n * @param a The first value.\n * @param b The second value.\n */\nexport function equals(a: any, b: any): boolean {\n\tconst shallowEquals =\n\t\ta === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === 'function' && a.equals(b))\n\treturn shallowEquals\n}\n\nexport declare function assertNever(x: never): never\n\n/** @public */\nexport const EMPTY_ARRAY: [] = Object.freeze([]) as any\n", "import { attach, detach } from './helpers.js'\nimport { Child, Signal } from './types.js'\n\nconst signiaKey = Symbol.for('__signia__')\nconst global = globalThis as { [signiaKey]?: true }\n\nif (global[signiaKey]) {\n\tconsole.error(\n\t\t'Multiple versions of signia detected. This will cause unexpected behavior. Please add \"resolutions\" (yarn/pnpm) or \"overrides\" (npm) in your package.json to ensure only one version of signia is loaded.'\n\t)\n} else {\n\tglobal[signiaKey] = true\n}\n\nclass CaptureStackFrame {\n\toffset = 0\n\tnumNewParents = 0\n\n\tmaybeRemoved?: Signal<any>[]\n\n\tconstructor(public readonly below: CaptureStackFrame | null, public readonly child: Child) {}\n}\n\nlet stack: CaptureStackFrame | null = null\n\n/**\n * Executes the given function without capturing any parents in the current capture context.\n *\n * This is mainly useful if you want to run an effect only when certain signals change while also\n * dereferencing other signals which should not cause the effect to rerun on their own.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Sam')\n * const time = atom('time', () => new Date().getTime())\n *\n * setInterval(() => {\n *   time.set(new Date().getTime())\n * })\n *\n * react('log name changes', () => {\n * \t console.log(name.value, 'was changed at', unsafe__withoutCapture(() => time.value))\n * })\n *\n * ```\n *\n * @public\n */\nexport function unsafe__withoutCapture<T>(fn: () => T): T {\n\tconst oldStack = stack\n\tstack = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tstack = oldStack\n\t}\n}\n\nexport function startCapturingParents(child: Child) {\n\tstack = new CaptureStackFrame(stack, child)\n}\n\nexport function stopCapturingParents() {\n\tconst frame = stack!\n\tstack = frame.below\n\n\tconst didParentsChange = frame.numNewParents > 0 || frame.offset !== frame.child.parents.length\n\n\tif (!didParentsChange) {\n\t\treturn\n\t}\n\n\tfor (let i = frame.offset; i < frame.child.parents.length; i++) {\n\t\tconst p = frame.child.parents[i]\n\t\tconst parentWasRemoved = frame.child.parents.indexOf(p) >= frame.offset\n\t\tif (parentWasRemoved) {\n\t\t\tdetach(p, frame.child)\n\t\t}\n\t}\n\n\tframe.child.parents.length = frame.offset\n\tframe.child.parentEpochs.length = frame.offset\n\n\tif (stack?.maybeRemoved) {\n\t\tfor (let i = 0; i < stack.maybeRemoved.length; i++) {\n\t\t\tconst maybeRemovedParent = stack.maybeRemoved[i]\n\t\t\tif (frame.child.parents.indexOf(maybeRemovedParent) === -1) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// this must be called after the parent is up to date\nexport function maybeCaptureParent(p: Signal<any, any>) {\n\tif (stack) {\n\t\tconst idx = stack.child.parents.indexOf(p)\n\t\t// if the child didn't deref this parent last time it executed, then idx will be -1\n\t\t// if the child did deref this parent last time but in a different order relative to other parents, then idx will be greater than stack.offset\n\t\t// if the child did deref this parent last time in the same order, then idx will be the same as stack.offset\n\t\t// if the child did deref this parent already during this capture session then 0 <= idx < stack.offset\n\n\t\tif (idx < 0) {\n\t\t\tstack.numNewParents++\n\t\t\tif (stack.child.isActivelyListening) {\n\t\t\t\tattach(p, stack.child)\n\t\t\t}\n\t\t}\n\n\t\tif (idx < 0 || idx >= stack.offset) {\n\t\t\tif (idx !== stack.offset && idx > 0) {\n\t\t\t\tconst maybeRemovedParent = stack.child.parents[stack.offset]\n\n\t\t\t\tif (!stack.maybeRemoved) {\n\t\t\t\t\tstack.maybeRemoved = [maybeRemovedParent]\n\t\t\t\t} else if (stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {\n\t\t\t\t\tstack.maybeRemoved.push(maybeRemovedParent)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack.child.parents[stack.offset] = p\n\t\t\tstack.child.parentEpochs[stack.offset] = p.lastChangedEpoch\n\t\t\tstack.offset++\n\t\t}\n\t}\n}\n\n/**\n * A debugging tool that tells you why a computed signal or effect is running.\n * Call in the body of a computed signal or effect function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Bob')\n * react('greeting', () => {\n * \twhyAmIRunning()\n *\tconsole.log('Hello', name.value)\n * })\n *\n * name.set('Alice')\n *\n * // 'greeting' is running because:\n * //     'name' changed => 'Alice'\n * ```\n *\n * @public\n */\nexport function whyAmIRunning() {\n\tconst child = stack?.child\n\tif (!child) {\n\t\tthrow new Error('whyAmIRunning() called outside of a reactive context')\n\t}\n\n\tconst changedParents = []\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\n\t\tif (parent.lastChangedEpoch > child.parentEpochs[i]) {\n\t\t\tchangedParents.push(parent)\n\t\t}\n\t}\n\n\tif (changedParents.length === 0) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running but none of the parents changed')\n\t} else {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running because:')\n\t\tfor (const changedParent of changedParents) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log(\n\t\t\t\t'\\t',\n\t\t\t\t(changedParent as any).name,\n\t\t\t\t'changed =>',\n\t\t\t\tchangedParent.__unsafe__getWithoutCapture()\n\t\t\t)\n\t\t}\n\t}\n}\n", "import { ArraySet } from './ArraySet.js'\nimport { _Computed } from './Computed.js'\nimport { EffectScheduler } from './EffectScheduler.js'\n\n/** @public */\nexport const RESET_VALUE: unique symbol = Symbol('RESET_VALUE')\n\n/** @public */\nexport type RESET_VALUE = typeof RESET_VALUE\n\n/**\n * A Signal is a reactive value container. The value may change over time, and it may keep track of the diffs between sequential values.\n *\n * There are two types of signal:\n *\n * - Atomic signals, created using [[atom]]. These are mutable references to values that can be changed using [[Atom.set]].\n * - Computed signals, created using [[computed]]. These are values that are computed from other signals. They are recomputed lazily if their dependencies change.\n *\n * @public\n */\nexport interface Signal<Value, Diff = unknown> {\n\t/**\n\t * The name of the signal. This is used at runtime for debugging and perf profiling only. It does not need to be globally unique.\n\t */\n\tname: string\n\t/**\n\t * The current value of the signal. This is a reactive value, and will update when the signal changes.\n\t * Any computed signal that depends on this signal will be lazily recomputed if this signal changes.\n\t * Any effect that depends on this signal will be rescheduled if this signal changes.\n\t */\n\treadonly value: Value\n\t/**\n\t * The epoch when this signal's value last changed. Note tha this is not the same as when the value was last computed.\n\t * A signal may recopmute it's value without changing it.\n\t */\n\tlastChangedEpoch: number\n\t/**\n\t * Returns the sequence of diffs between the the value at the given epoch and the current value.\n\t * Returns the [[RESET_VALUE]] constant if there is not enough information to compute the diff sequence.\n\t * @param epoch\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[]\n\t/**\n\t * Returns the current value of the signal without capturing it as a dependency.\n\t * Use this if you need to retrieve the signal's value in a hot loop where the performance overhead of dependency tracking is too high.\n\t */\n\t__unsafe__getWithoutCapture(): Value\n\t/** @internal */\n\tchildren: ArraySet<Child>\n}\n\n/** @internal */\nexport type Child = EffectScheduler<any> | _Computed<any>\n\n/**\n * Computes the diff between the previous and current value.\n *\n * If the diff cannot be computed for whatever reason, it should return [[RESET_VALUE]].\n *\n * @public\n */\nexport type ComputeDiff<Value, Diff> = (\n\tpreviousValue: Value,\n\tcurrentValue: Value,\n\tlastComputedEpoch: number,\n\tcurrentEpoch: number\n) => Diff | RESET_VALUE\n", "import { RESET_VALUE } from './types.js'\n\ntype RangeTuple<Diff> = [fromEpoch: number, toEpoch: number, diff: Diff]\n\n/**\n * A structure that stores diffs between values of an atom.\n *\n * @internal\n */\nexport class HistoryBuffer<Diff> {\n\tprivate index = 0\n\n\t// use a wrap around buffer to store the last N values\n\tbuffer: Array<RangeTuple<Diff> | undefined>\n\n\tconstructor(private readonly capacity: number) {\n\t\tthis.buffer = new Array(capacity)\n\t}\n\n\t/**\n\t * Add a diff to the history buffer.\n\t *\n\t * @param lastComputedEpoch The epoch when the diff was computed.\n\t * @param currentEpoch The current epoch.\n\t * @param diff (optional) The diff to add, or else a reset value.\n\t */\n\tpushEntry(lastComputedEpoch: number, currentEpoch: number, diff: Diff | RESET_VALUE) {\n\t\tif (diff === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\tthis.clear()\n\t\t\treturn\n\t\t}\n\n\t\t// Add the diff to the buffer as a range tuple.\n\t\tthis.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff]\n\n\t\t// Bump the index, wrapping around if necessary.\n\t\tthis.index = (this.index + 1) % this.capacity\n\t}\n\n\t/**\n\t * Clear the history buffer.\n\t */\n\tclear() {\n\t\tthis.index = 0\n\t\tthis.buffer.fill(undefined)\n\t}\n\n\t/**\n\t * Get the diffs since the given epoch.\n\t *\n\t * @param epoch The epoch to get diffs since.\n\t * @returns An array of diffs or a flag to reset the history buffer.\n\t */\n\tgetChangesSince(sinceEpoch: number): RESET_VALUE | Diff[] {\n\t\tconst { index, capacity, buffer } = this\n\n\t\t// For each item in the buffer...\n\t\tfor (let i = 0; i < capacity; i++) {\n\t\t\tconst offset = (index - 1 + capacity - i) % capacity\n\n\t\t\tconst elem = buffer[offset]\n\n\t\t\t// If there's no element in the offset position, return the reset value\n\t\t\tif (!elem) {\n\t\t\t\treturn RESET_VALUE\n\t\t\t}\n\n\t\t\tconst [fromEpoch, toEpoch] = elem\n\n\t\t\t// If the first element is already too early, bail\n\t\t\tif (i === 0 && sinceEpoch >= toEpoch) {\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\t// If the element is since the given epoch, return an array with all diffs from this element and all following elements\n\t\t\tif (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {\n\t\t\t\tconst len = i + 1\n\t\t\t\tconst result = new Array(len)\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tresult[j] = buffer[(offset + j) % capacity]![2]\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't returned yet, return the reset value\n\t\treturn RESET_VALUE\n\t}\n}\n", "// Derivations start on GLOBAL_START_EPOCH so they are dirty before having been computed\nexport const GLOBAL_START_EPOCH = -1\n", "import { _Atom } from './Atom.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { EffectScheduler } from './EffectScheduler.js'\nimport { Child, Signal } from './types.js'\n\n// The current epoch (global to all atoms).\nexport let globalEpoch = GLOBAL_START_EPOCH + 1\n\n// Whether any transaction is reacting.\nlet globalIsReacting = false\n\nexport function advanceGlobalEpoch() {\n\tglobalEpoch++\n}\n\nclass Transaction {\n\tconstructor(public readonly parent: Transaction | null) {}\n\tinitialAtomValues = new Map<_Atom<any>, any>()\n\n\t/**\n\t * Get whether this transaction is a root (no parents).\n\t *\n\t * @public\n\t */\n\tget isRoot() {\n\t\treturn this.parent === null\n\t}\n\n\t/**\n\t * Commit the transaction's changes.\n\t *\n\t * @public\n\t */\n\tcommit() {\n\t\tif (this.isRoot) {\n\t\t\t// For root transactions, flush changes to each of the atom's initial values.\n\t\t\tconst atoms = this.initialAtomValues\n\t\t\tthis.initialAtomValues = new Map()\n\t\t\tflushChanges(atoms.keys())\n\t\t} else {\n\t\t\t// For transaction's with parents, add the transaction's initial values to the parent's.\n\t\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\t\tif (!this.parent!.initialAtomValues.has(atom)) {\n\t\t\t\t\tthis.parent!.initialAtomValues.set(atom, value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction.\n\t *\n\t * @public\n\t */\n\tabort() {\n\t\tglobalEpoch++\n\n\t\t// Reset each of the transaction's atoms to its initial value.\n\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\tatom.set(value)\n\t\t\tatom.historyBuffer?.clear()\n\t\t})\n\n\t\t// Commit the changes.\n\t\tthis.commit()\n\t}\n}\n\n/**\n * Collect all of the reactors that need to run for an atom and run them.\n *\n * @param atom The atom to flush changes for.\n */\nfunction flushChanges(atoms: Iterable<_Atom<any>>) {\n\tif (globalIsReacting) {\n\t\tthrow new Error('cannot change atoms during reaction cycle')\n\t}\n\n\ttry {\n\t\tglobalIsReacting = true\n\n\t\t// Collect all of the visited reactors.\n\t\tconst reactors = new Set<EffectScheduler<unknown>>()\n\n\t\t// Visit each descendant of the atom, collecting reactors.\n\t\tconst traverse = (node: Child) => {\n\t\t\tif (node.lastTraversedEpoch === globalEpoch) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnode.lastTraversedEpoch = globalEpoch\n\n\t\t\tif ('maybeScheduleEffect' in node) {\n\t\t\t\treactors.add(node)\n\t\t\t} else {\n\t\t\t\t;(node as any as Signal<any>).children.visit(traverse)\n\t\t\t}\n\t\t}\n\n\t\tfor (const atom of atoms) {\n\t\t\tatom.children.visit(traverse)\n\t\t}\n\n\t\t// Run each reactor.\n\t\tfor (const r of reactors) {\n\t\t\tr.maybeScheduleEffect()\n\t\t}\n\t} finally {\n\t\tglobalIsReacting = false\n\t}\n}\n\n/**\n * Handle a change to an atom.\n *\n * @param atom The atom that changed.\n * @param previousValue The atom's previous value.\n *\n * @internal\n */\nexport function atomDidChange(atom: _Atom<any>, previousValue: any) {\n\tif (!currentTransaction) {\n\t\tflushChanges([atom])\n\t} else if (!currentTransaction.initialAtomValues.has(atom)) {\n\t\tcurrentTransaction.initialAtomValues.set(atom, previousValue)\n\t}\n}\n\n/**\n * The current transaction, if there is one.\n *\n * @global\n * @public\n */\nexport let currentTransaction = null as Transaction | null\n\n/**\n * Batches state updates, deferring side effects until after the transaction completes.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n * })\n *\n * // Logs \"Hello, Jane Smith!\"\n * ```\n *\n * If the function throws, the transaction is aborted and any signals that were updated during the transaction revert to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  throw new Error('oops')\n * })\n *\n * // Does not log\n * // firstName.value === 'John'\n * ```\n *\n * A `rollback` callback is passed into the function.\n * Calling this will prevent the transaction from committing and will revert any signals that were updated during the transaction to their state before the transaction began.\n *\n *  * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction((rollback) => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n *  rollback()\n * })\n *\n * // Does not log\n * // firstName.value === 'John'\n * // lastName.value === 'Doe'\n * ```\n *\n * @param fn The function to run in a transaction, called with a function to roll back the change.\n * @public\n */\nexport function transaction<T>(fn: (rollback: () => void) => T) {\n\tconst txn = new Transaction(currentTransaction)\n\n\t// Set the current transaction to the transaction\n\tcurrentTransaction = txn\n\n\ttry {\n\t\tlet rollback = false\n\n\t\t// Run the function.\n\t\tconst result = fn(() => (rollback = true))\n\n\t\tif (rollback) {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\ttxn.abort()\n\t\t} else {\n\t\t\t// Otherwise, commit the transaction.\n\t\t\ttxn.commit()\n\t\t}\n\n\t\treturn result\n\t} catch (e) {\n\t\t// Abort the transaction if the function throws.\n\t\ttxn.abort()\n\t\tthrow e\n\t} finally {\n\t\t// Set the current transaction to the transaction's parent.\n\t\tcurrentTransaction = currentTransaction.parent\n\t}\n}\n\n/**\n * Like [transaction](#transaction), but does not create a new transaction if there is already one in progress.\n *\n * @param fn\n * @public\n */\nexport function transact<T>(fn: () => T): T {\n\tif (currentTransaction) {\n\t\treturn fn()\n\t}\n\treturn transaction(fn)\n}\n", "import { ArraySet } from './ArraySet.js'\nimport { maybeCaptureParent } from './capture.js'\nimport { EMPTY_ARRAY, equals } from './helpers.js'\nimport { HistoryBuffer } from './HistoryBuffer.js'\nimport { advanceGlobalEpoch, atomDidChange, globalEpoch } from './transactions.js'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types.js'\n\n/**\n * The options to configure an atom, passed into the [[atom]] function.\n * @public\n */\nexport interface AtomOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a\n\t * @param b\n\t * @returns\n\t */\n\tisEqual?: (a: any, b: any) => boolean\n}\n\n/**\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * Atoms are created using the [[atom]] function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * console.log(name.value) // 'John'\n * ```\n *\n * @public\n */\nexport interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set.\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using [[AtomOptions.computeDiff]].\n\t */\n\tset(value: Value, diff?: Diff): Value\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value.\n\t */\n\tupdate(updater: (value: Value) => Value): Value\n}\n\n/**\n * @internal\n */\nexport class _Atom<Value, Diff = unknown> implements Atom<Value, Diff> {\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate current: Value,\n\t\toptions?: AtomOptions<Value, Diff>\n\t) {\n\t\tthis.isEqual = options?.isEqual ?? null\n\n\t\tif (!options) return\n\n\t\tif (options.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\n\t\tthis.computeDiff = options.computeDiff\n\t}\n\n\treadonly isEqual: null | ((a: any, b: any) => boolean)\n\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\n\tlastChangedEpoch = globalEpoch\n\n\tchildren = new ArraySet<Child>()\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t__unsafe__getWithoutCapture(): Value {\n\t\treturn this.current\n\t}\n\n\tget value() {\n\t\tmaybeCaptureParent(this)\n\t\treturn this.current\n\t}\n\n\tset(value: Value, diff?: Diff): Value {\n\t\t// If the value has not changed, do nothing.\n\t\tif (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {\n\t\t\treturn this.current\n\t\t}\n\n\t\t// Tick forward the global epoch\n\t\tadvanceGlobalEpoch()\n\n\t\t// Add the diff to the history buffer.\n\t\tif (this.historyBuffer) {\n\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\tglobalEpoch,\n\t\t\t\tdiff ??\n\t\t\t\t\tthis.computeDiff?.(this.current, value, this.lastChangedEpoch, globalEpoch) ??\n\t\t\t\t\tRESET_VALUE\n\t\t\t)\n\t\t}\n\n\t\t// Update the atom's record of the epoch when last changed.\n\t\tthis.lastChangedEpoch = globalEpoch\n\n\t\tconst oldValue = this.current\n\t\tthis.current = value\n\n\t\t// Notify all children that this atom has changed.\n\t\tatomDidChange(this, oldValue)\n\n\t\treturn value\n\t}\n\n\tupdate(updater: (value: Value) => Value): Value {\n\t\treturn this.set(updater(this.current))\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\tmaybeCaptureParent(this)\n\n\t\t// If no changes have occurred since the given epoch, return an empty array.\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\n/**\n * Creates a new [[Atom]].\n *\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * name.value // 'John'\n *\n * name.set('Jane')\n *\n * name.value // 'Jane'\n * ```\n *\n * @public\n */\nexport function atom<Value, Diff = unknown>(\n\t/**\n\t * A name for the signal. This is used for debugging and profiling purposes, it does not need to be unique.\n\t */\n\tname: string,\n\t/**\n\t * The initial value of the signal.\n\t */\n\tinitialValue: Value,\n\t/**\n\t * The options to configure the atom. See [[AtomOptions]].\n\t */\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn new _Atom(name, initialValue, options)\n}\n\n/**\n * Returns true if the given value is an [[Atom]].\n * @public\n */\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn value instanceof _Atom\n}\n", "/* eslint-disable prefer-rest-params */\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types.js'\n\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from './capture.js'\n\nimport { ArraySet } from './ArraySet.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { EMPTY_ARRAY, equals, haveParentsChanged } from './helpers.js'\nimport { HistoryBuffer } from './HistoryBuffer.js'\nimport { globalEpoch } from './transactions.js'\n\nconst UNINITIALIZED = Symbol('UNINITIALIZED')\n/**\n * The type of the first value passed to a computed signal function as the 'prevValue' parameter.\n *\n * @see [[isUninitialized]].\n * @public\n */\ntype UNINITIALIZED = typeof UNINITIALIZED\n\n/**\n * Call this inside a computed signal function to determine whether it is the first time the function is being called.\n *\n * Mainly useful for incremental signal computation.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     console.log('First time!')\n *   }\n *   return count.value * 2\n * })\n *\n * @param value - The value to check.\n * @public\n */\nexport const isUninitialized = (value: any): value is UNINITIALIZED => {\n\treturn value === UNINITIALIZED\n}\n\nclass WithDiff<Value, Diff> {\n\tconstructor(public value: Value, public diff: Diff) {}\n}\n\n/**\n * When writing incrementally-computed signals it is convenient (and usually more performant) to incrementally compute the diff too.\n *\n * You can use this function to wrap the return value of a computed signal function to indicate that the diff should be used instead of calculating a new one with [[AtomOptions.computeDiff]].\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.value * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * }, { historyLength: 10 })\n * ```\n *\n *\n * @param value - The value.\n * @param diff - The diff.\n * @public\n */\nexport function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff> {\n\treturn new WithDiff(value, diff)\n}\n\n/**\n * Options for creating computed signals. Used when calling [[computed]].\n * @public\n */\nexport interface ComputedOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a\n\t * @param b\n\t * @returns\n\t */\n\tisEqual?: (a: any, b: any) => boolean\n}\n\n/**\n * A computed signal created via [[computed]].\n *\n * @public\n */\nexport interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Whether this computed child is involved in an actively-running effect graph.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\t/** @internal */\n\treadonly parentEpochs: number[]\n}\n\n/**\n * @internal\n */\nexport class _Computed<Value, Diff = unknown> implements Computed<Value, Diff> {\n\tlastChangedEpoch = GLOBAL_START_EPOCH\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t/**\n\t * The epoch when the reactor was last checked.\n\t */\n\tprivate lastCheckedEpoch = GLOBAL_START_EPOCH\n\n\tparents: Signal<any, any>[] = []\n\tparentEpochs: number[] = []\n\n\tchildren = new ArraySet<Child>()\n\n\tget isActivelyListening(): boolean {\n\t\treturn !this.children.isEmpty\n\t}\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t// The last-computed value of this signal.\n\tprivate state: Value = UNINITIALIZED as unknown as Value\n\n\tprivate computeDiff?: ComputeDiff<Value, Diff>\n\n\tprivate readonly isEqual: (a: any, b: any) => boolean\n\n\tconstructor(\n\t\t/**\n\t\t * The name of the signal. This is used for debugging and performance profiling purposes. It does not need to be globally unique.\n\t\t */\n\t\tpublic readonly name: string,\n\t\t/**\n\t\t * The function that computes the value of the signal.\n\t\t */\n\t\tprivate readonly derive: (\n\t\t\tpreviousValue: Value | UNINITIALIZED,\n\t\t\tlastComputedEpoch: number\n\t\t) => Value | WithDiff<Value, Diff>,\n\t\toptions?: ComputedOptions<Value, Diff>\n\t) {\n\t\tif (options?.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\t\tthis.computeDiff = options?.computeDiff\n\t\tthis.isEqual = options?.isEqual ?? equals\n\t}\n\n\t__unsafe__getWithoutCapture(): Value {\n\t\tconst isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH\n\n\t\tif (!isNew && (this.lastCheckedEpoch === globalEpoch || !haveParentsChanged(this))) {\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\t\t\treturn this.state\n\t\t}\n\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.derive(this.state, this.lastCheckedEpoch)\n\t\t\tconst newState = result instanceof WithDiff ? result.value : result\n\t\t\tif (this.state === UNINITIALIZED || !this.isEqual(newState, this.state)) {\n\t\t\t\tif (this.historyBuffer && !isNew) {\n\t\t\t\t\tconst diff = result instanceof WithDiff ? result.diff : undefined\n\t\t\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\t\t\tglobalEpoch,\n\t\t\t\t\t\tdiff ??\n\t\t\t\t\t\t\tthis.computeDiff?.(this.state, newState, this.lastCheckedEpoch, globalEpoch) ??\n\t\t\t\t\t\t\tRESET_VALUE\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.lastChangedEpoch = globalEpoch\n\t\t\t\tthis.state = newState\n\t\t\t}\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\n\t\t\treturn this.state\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n\n\tget value(): Value {\n\t\tconst value = this.__unsafe__getWithoutCapture()\n\t\tmaybeCaptureParent(this)\n\t\treturn value\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\t// need to call .value to ensure both that this derivation is up to date\n\t\t// and that tracking happens correctly\n\t\tthis.value\n\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nfunction computedAnnotation(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.get\n\tconst derivationKey = Symbol.for('__signia__computed__' + key)\n\n\tdescriptor.get = function (this: any) {\n\t\tlet d = this[derivationKey] as _Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.value\n\t}\n\n\treturn descriptor\n}\n\n/**\n * Retrieves the underlying computed instance for a given property created with the [[computed]]\n * decorator.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom(0)\n *\n *   @computed get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n *\n * const c = new Counter()\n * const remaining = getComputedInstance(c, 'remaining')\n * remaining.value === 100 // true\n * c.count.set(13)\n * remaining.value === 87 // true\n * ```\n *\n * @param obj\n * @param propertyName\n * @public\n */\nexport function getComputedInstance<Obj extends object, Prop extends keyof Obj>(\n\tobj: Obj,\n\tpropertyName: Prop\n): Computed<Obj[Prop]> {\n\t// deref to make sure it exists first\n\tconst key = Symbol.for('__signia__computed__' + propertyName.toString())\n\tlet inst = obj[key as keyof typeof obj] as _Computed<Obj[Prop]> | undefined\n\tif (!inst) {\n\t\t// deref to make sure it exists first\n\t\tobj[propertyName]\n\t\tinst = obj[key as keyof typeof obj] as _Computed<Obj[Prop]> | undefined\n\t}\n\treturn inst as any\n}\n\n/**\n * Creates a computed signal.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n * const greeting = computed('greeting', () => `Hello ${name.value}!`)\n * console.log(greeting.value) // 'Hello John!'\n * ```\n *\n * `computed` may also be used as a decorator for creating computed class properties.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n * ```\n *\n * You may optionally pass in a [[ComputedOptions]] when used as a decorator:\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed({isEqual: (a, b) => a === b})\n *   get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n * ```\n *\n * @param name - The name of the signal.\n * @param compute - The function that computes the value of the signal.\n * @param options - Options for the signal.\n *\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: (\n\t\tpreviousValue: Value | typeof UNINITIALIZED,\n\t\tlastComputedEpoch: number\n\t) => Value | WithDiff<Value, Diff>,\n\toptions?: ComputedOptions<Value, Diff>\n): Computed<Value, Diff>\n\n/** @public */\nexport function computed(\n\ttarget: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n): PropertyDescriptor\n/** @public */\nexport function computed<Value, Diff = unknown>(\n\toptions?: ComputedOptions<Value, Diff>\n): (target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor\n/** @public */\nexport function computed() {\n\tif (arguments.length === 1) {\n\t\tconst options = arguments[0]\n\t\treturn (target: any, key: string, descriptor: PropertyDescriptor) =>\n\t\t\tcomputedAnnotation(options, target, key, descriptor)\n\t} else if (typeof arguments[0] === 'string') {\n\t\treturn new _Computed(arguments[0], arguments[1], arguments[2])\n\t} else {\n\t\treturn computedAnnotation(undefined, arguments[0], arguments[1], arguments[2])\n\t}\n}\n\n/**\n * Returns true if the given value is a computed signal.\n *\n * @param value\n * @returns {value is Computed<any>}\n * @public\n */\nexport function isComputed(value: any): value is Computed<any> {\n\treturn value && value instanceof _Computed\n}\n", "import { startCapturingParents, stopCapturingParents } from './capture.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { attach, detach, haveParentsChanged } from './helpers.js'\nimport { globalEpoch } from './transactions.js'\nimport { Signal } from './types.js'\n\ninterface EffectSchedulerOptions {\n\t/**\n\t * scheduleEffect is a function that will be called when the effect is scheduled.\n\t *\n\t * It can be used to defer running effects until a later time, for example to batch them together with requestAnimationFrame.\n\t *\n\t *\n\t * @example\n\t * ```ts\n\t * let isRafScheduled = false\n\t * const scheduledEffects: Array<() => void> = []\n\t * const scheduleEffect = (runEffect: () => void) => {\n\t * \tscheduledEffects.push(runEffect)\n\t * \tif (!isRafScheduled) {\n\t * \t\tisRafScheduled = true\n\t * \t\trequestAnimationFrame(() => {\n\t * \t\t\tisRafScheduled = false\n\t * \t\t\tscheduledEffects.forEach((runEffect) => runEffect())\n\t * \t\t\tscheduledEffects.length = 0\n\t * \t\t})\n\t * \t}\n\t * }\n\t * const stop = react('set page title', () => {\n\t * \tdocument.title = doc.title,\n\t * }, scheduleEffect)\n\t * ```\n\t *\n\t * @param execute\n\t * @returns\n\t */\n\tscheduleEffect?: (execute: () => void) => void\n}\n\n/**\n * An EffectScheduler is responsible for executing side effects in response to changes in state.\n *\n * You probably don't need to use this directly unless you're integrating Signia with a framework of some kind.\n *\n * Instead, use the [[react]] and [[reactor]] functions.\n *\n * @example\n * ```ts\n * const render = new EffectScheduler('render', drawToCanvas)\n *\n * render.attach()\n * render.execute()\n * ```\n *\n * @public\n */\nexport class EffectScheduler<Result> {\n\tprivate _isActivelyListening = false\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\tget isActivelyListening() {\n\t\treturn this._isActivelyListening\n\t}\n\t/** @internal */\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\tprivate lastReactedEpoch = GLOBAL_START_EPOCH\n\tprivate _scheduleCount = 0\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\tget scheduleCount() {\n\t\treturn this._scheduleCount\n\t}\n\n\t/** @internal */\n\tparentEpochs: number[] = []\n\t/** @internal */\n\tparents: Signal<any, any>[] = []\n\tprivate readonly _scheduleEffect?: (execute: () => void) => void\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate readonly runEffect: (lastReactedEpoch: number) => Result,\n\t\toptions?: EffectSchedulerOptions\n\t) {\n\t\tthis._scheduleEffect = options?.scheduleEffect\n\t}\n\n\t/** @internal */\n\tmaybeScheduleEffect() {\n\t\t// bail out if we have been cancelled by another effect\n\t\tif (!this._isActivelyListening) return\n\t\t// bail out if no atoms have changed since the last time we ran this effect\n\t\tif (this.lastReactedEpoch === globalEpoch) return\n\n\t\t// bail out if we have parents and they have not changed since last time\n\t\tif (this.parents.length && !haveParentsChanged(this)) {\n\t\t\tthis.lastReactedEpoch = globalEpoch\n\t\t\treturn\n\t\t}\n\t\t// if we don't have parents it's probably the first time this is running.\n\t\tthis.scheduleEffect()\n\t}\n\n\t/** @internal */\n\tscheduleEffect() {\n\t\tthis._scheduleCount++\n\t\tif (this._scheduleEffect) {\n\t\t\t// if the effect should be deferred (e.g. until a react render), do so\n\t\t\tthis._scheduleEffect(this.maybeExecute)\n\t\t} else {\n\t\t\t// otherwise execute right now!\n\t\t\tthis.execute()\n\t\t}\n\t}\n\n\tprivate maybeExecute = () => {\n\t\t// bail out if we have been detached before this runs\n\t\tif (!this._isActivelyListening) return\n\t\tthis.execute()\n\t}\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].\n\t * @public\n\t */\n\tattach() {\n\t\tthis._isActivelyListening = true\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tattach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.\n\t */\n\tdetach() {\n\t\tthis._isActivelyListening = false\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tdetach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result {\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.runEffect(this.lastReactedEpoch)\n\t\t\tthis.lastReactedEpoch = globalEpoch\n\t\t\treturn result\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n}\n\n/**\n * Starts a new effect scheduler, scheduling the effect immediately.\n *\n * Returns a function that can be called to stop the scheduler.\n *\n * @example\n * ```ts\n * const color = atom('color', 'red')\n * const stop = react('set style', () => {\n *   divElem.style.color = color.value\n * })\n * color.set('blue')\n * // divElem.style.color === 'blue'\n * stop()\n * color.set('green')\n * // divElem.style.color === 'blue'\n * ```\n *\n *\n * Also useful in React applications for running effects outside of the render cycle.\n *\n * @example\n * ```ts\n * useEffect(() => react('set style', () => {\n *   divRef.current.style.color = color.value\n * }), [])\n * ```\n *\n * @public\n */\nexport function react(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => any,\n\toptions?: EffectSchedulerOptions\n) {\n\tconst scheduler = new EffectScheduler(name, fn, options)\n\tscheduler.attach()\n\tscheduler.scheduleEffect()\n\treturn () => {\n\t\tscheduler.detach()\n\t}\n}\n\n/**\n * The reactor is a user-friendly interface for starting and stopping an [[EffectScheduler]].\n *\n * Calling .start() will attach the scheduler and execute the effect immediately the first time it is called.\n *\n * If the reactor is stopped, calling `.start()` will re-attach the scheduler but will only execute the effect if any of its parents have changed since it was stopped.\n *\n * You can create a reactor with [[reactor]].\n * @public\n */\nexport interface Reactor<T = unknown> {\n\t/**\n\t * The underlying effect scheduler.\n\t * @public\n\t */\n\tscheduler: EffectScheduler<T>\n\t/**\n\t * Start the scheduler. The first time this is called the effect will be scheduled immediately.\n\t *\n\t * If the reactor is stopped, calling this will start the scheduler again but will only execute the effect if any of its parents have changed since it was stopped.\n\t *\n\t * If you need to force re-execution of the effect, pass `{ force: true }`.\n\t * @public\n\t */\n\tstart(options?: { force?: boolean }): void\n\t/**\n\t * Stop the scheduler.\n\t * @public\n\t */\n\tstop(): void\n}\n\n/**\n * Creates a [[Reactor]], which is a thin wrapper around an [[EffectScheduler]].\n *\n * @public\n */\nexport function reactor<Result>(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => Result,\n\toptions?: EffectSchedulerOptions\n): Reactor<Result> {\n\tconst scheduler = new EffectScheduler<Result>(name, fn, options)\n\treturn {\n\t\tscheduler,\n\t\tstart: (options?: { force?: boolean }) => {\n\t\t\tconst force = options?.force ?? false\n\t\t\tscheduler.attach()\n\t\t\tif (force) {\n\t\t\t\tscheduler.scheduleEffect()\n\t\t\t} else {\n\t\t\t\tscheduler.maybeScheduleEffect()\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tscheduler.detach()\n\t\t},\n\t}\n}\n", "import { _Atom } from './Atom.js'\nimport { _Computed } from './Computed.js'\nimport { Signal } from './types.js'\n\n/**\n * Returns true if the given value is a signal (either an Atom or a Computed).\n * @public\n */\nexport function isSignal(value: any): value is Signal<any> {\n\treturn value instanceof _Atom || value instanceof _Computed\n}\n", "/**\n * **signia** is a reactive signals library for TypeScript.\n *\n * See [the github repo](https://github.com/tldraw/signia) for more information.\n *\n * @packageDocumentation\n */\n\nexport * from './api.js'\nimport * as signia from './api.js'\nexport default signia\n"],
  "mappings": "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",
  "names": ["atom", "options"]
}
